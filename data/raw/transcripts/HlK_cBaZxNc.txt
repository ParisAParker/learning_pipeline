What's up, guys? I wanted to highlight
an interview experience that I had. And
I picked this one in particular because
a lot of people think that knowledge
rounds don't exist and that all they
need to do in an interview is, you know,
memorize Koko's bananas on lead code and
grind lead code and then they'll be okay
and that none if anything that I talk
about matters either in the interview or
on the job. And that's just not the
case. The interview landscape is
changing. I also wanted to kind of
highlight this whole notion as you can
just Google it as being totally absurd.
So while you're watching this interview,
just imagine that every question that
the interviewer asked, I just say,
"Well, I can just Google that and just
imagine how he or she might have
reacted." And there's also a group of
people out there, you guys know who they
are. They're my most loyal viewers and
commenters. They're there in every video
in the comment section. Uh spreading
lies essentially that, you know, the
people that I interview are paid actors
or that while I play video games and
interview people, somehow I have a third
eye that I'm using to to read the
answers and I don't know anything and
it's just all a a hoax or something and
911 didn't happen or whatever. But um
yeah, keep in mind that I used
getcrack.io to prepare for this
interview entirely. So, if you're ever
curious as to how I learned the things
that I learned here, uh, that's what I
used, get crack.io. Needless to say, I
got pushed to the final round of this
quant trading firm's interview process
after this interview
plus this mutable keyword. Have you used
that before?
Yeah, I have.
For in in what cases?
I've used it in the context of data
members as part private data members as
part of a class and I've also used it in
the context of a lambda.
context of lambda.
Yeah, lambdas can have two keywords,
they can have they could be marked as no
except and be marked as mutable
because all
Yeah, if you take if you take uh
something if you capture by copy, you
can't mutate that object that's captured
by copy in the lambda unless you add the
mutable keyword to the lambda after the
parameter list.
Okay, that's good. That's good. All
right. So let's move away from C++ a
little bit. So um well in design pattern
there is one pattern called a singleton.
Yeah.
Um if I ask you to implement a singleton
class
um how would you do that?
I just want to note that this is
literally a question that was on get
crack.io.
Sure. So when it comes to implementing a
singleton, you need to have one instance
of that object and you need to be able
to
what I would usually do is I would make
the constructor of that singleton
private
so that you can't just create one on the
stack.
Okay. Okay.
The next thing that I would do is I
would have a static method
that calls like instance and returns a
reference to that object. Now where is
that object created? In the instance
method, I would have a static um a
static variable of that created object
and that objects created on the first
time we call that static instance
method.
Hold on. Can you say it again? A static
me static object of this of this class.
Is it?
Yeah, it's a static object, but it's
inside the instance method. So there's a
static method called instance, and
inside instance, there's a static class
A. I see. I see. I see. I see. I get it.
I get it. Okay. I see. It's a a function
local static.
Yes. Yes.
I see.
Um,
okay. That works.
Just a note, something I did forget to
mention here because I got caught up in
explaining the thread safety of the
initialization of local static variables
is that you also need to delete the copy
constructor, copy assignment operator,
move constructor, and move assignment
operator. That would be important to
bring up in an interview,
but it's not thread safe. It actually is
because static local static member
variable local static variables will
only be initialized
once and static initialization for those
local variables are always thread safe
really
somehow maybe it's a recent standard
change or not not recent but what I
remember at least many years ago thread
local static are not thread local
function local static are not thread
safe.
If you just have static the type and the
object name that you're instantiating
inside a a method that's guaranteed to
be thread safe.
Okay, that's that's sort of again what I
have believed before. So I guess maybe I
was wrong. I can do more research on
this then. I see. I always thought a
static a function local static is not
thread safe.
I remember yeah I remember very clearly
that that's one of the benefits of that
approach is the thread safety provided
by the static part of that method.
So then it has to be the compiler is
guaranteed that right or the C++
standard is guaranteed that
C++ standard guarantees that. Yeah
okay that's good to know. Yeah.
And uh okay. So since we're talking
about
thread uh multi- threading um mutx and
conditional variable, what are they and
how do you use them?
Yeah. So I like to think of mutx and
condition variable as they're obviously
two separate things but they serve a
distinct purpose. So condition variable
is for like signaling usually I would
use between two threads. So like you
have the wait call, you have the notify
one, notify all, and then on the mutex,
there's different types of mutexes. Most
are hybrid. What do I mean by that? They
they when you try to acquire it, it'll
spin for a couple of CPU cycles. And if
it cannot acquire the lock, it can't if
it can't acquire a degree of mutual
exclusion, it'll then yield to the
taskuler. So it'll say, I've I've tried.
Now I'm I'm not going to waste more time
trying. Whenever you want, bring me
back. I'll try again. So the mutex has
the API lock unlock and it's usually
passed to like a scoped lock or a unique
lock and then the condition variable is
used for cross thread communication with
notify one notify all and then wait.
Sounds good. Sounds good. So per your
past experience
when I'm acquiring a mutex yeah and it
is not contended meaning that it's it's
free it's open nobody is there
currently
uh how much time normally it takes
if you did the implement a mutx question
alongside any other sort of concurrency
problems on get crack.io IO, you'll
knock this question out of the park.
It's usually instantaneous or very close
to instantaneous.
The lock itself, if it's implemented as
a spin lock, it usually has two
operations that it needs to do before it
acquires the lock. And that is it might
do like a load on an atomic variable to
check if the flag is set in a relaxed
fashion. And then it'll do an exchange.
So it'll exchange a if the value is
unset, it's zero, then it'll exchange it
for one. So that's a read modify write
operation. So it has those two
operations. Exactly how long that takes.
Read modify write.
Those are three instructions. Uh three
times the clock speed maybe a couple of
nanconds. You know I I don't know the
exact
okay number.
That's that's good enough. That's good
enough. All right. So um
the well actually back to C++. I I I
recall another question. So um I I I
assume you've written some template
code.
Yeah.
So far, right? Okay. So
is a template template code does it have
to be in a header file?
Uh no, it doesn't need to be in a header
file. But if you put the implementation,
for example, so let's say I declare the
I declare a template, but I don't define
it in the header. I define it in the CPP
file. I need to now explicitly
instantiate
in that CPP at the bottom the forms of
That's good.
Yeah,
that's good. That's good. That's all I
need to hear.
Okay.
Um Okay. Uh network, you must have done
some network related stuff, right?
Yeah.
Okay. So, um two questions. One, if I
want to start a TCP server, what system
calls do you need in what order?
Oh, okay. TCP server. So, it's been a
while since I did socket programming,
but let me think here. So, I believe the
first thing you have to do is like
create a socket. I know that there's
sometimes I use the there's a e- pole
select and pull. Those are a little
later, but you have to create the socket
with inet or I forget the exact header
that it's contained in
socket. Then you call set sock options.
So you set like keep alive, TCP message
buffer size, uh port and then you also
have accept to receive incoming
connections.
Um and then you have
Wait, I think you jumped too fast.
Okay.
Between between sockets or set up set
socket option which is optional and
except there's something else.
Oh. Oh. Oh. Server address. Server
address. There's a I believe so you you
have to you have to create the strct
server adder or something and you need
to zero it out and then set it and then
I believe there's like something for the
ports h toll or something to call to
change the port.
Yeah, that's right. That's right. That's
right. Okay. All right. So I guess you
you've done this before clearly but uh
it has been a while, right?
Yeah.
Okay. Okay. That that's fine. That's
fine. So um
I'm going to ask you to u
um let's let's let's design a system.
Sure. A
I call it least recently used cache.
Okay.
Your design the system is called least
recently used cache meaning that you
need to well when you when you do the
computation you can assume there is a
function global available function that
really does the computation right. So so
that is always aware available
somewhere.
Okay.
Um so once you have the result and the
output input you will need to cach it
somewhere. So next time when we call get
again you can look it up very fast.
Yeah. But then you have a finite
capacity when you h you when you when
you have
um enough key value pairs or input
output pairs in your procession you're
going to and there's a new one comes in
you're going to kick out the eviction
policy is least recently used.
Yeah.
Is it clear so far the requirement?
Yeah I think the requirement is clear.
Okay. So your task is to design the
internal what data structure what's the
general logic would be
okay so the first thing that I would
have because you mentioned capacity we
need to store that somewhere right we
need to store when we would like to
evict and we evict when we reach
capacity so I would store like a size t
variable capacity there's no such thing
as a negative capacity so size t
unsigned uh is totally fine there um we
have a key and a value and we call Like
is it called add? Is that the name of
the API? Like we add the item into the
into
No, it's just called get.
Oh, called get. Okay.
Um
so get and you pass in the key, right?
You pass the key, return a value. Yeah.
Okay. Um I think what I would do is the
first thing I would do is I would check
capacity.
Let's say the let's say we have the case
where we're at capacity, right? Now we
need to rely on another data structure
to store like which one do we evict
first? What I would do to have like an
ordering as to which keys are most stale
and which keys are least stale, I'd
probably have them in like a stood list
and the template type would be key. And
then the ones that are stale, the keys
that are stale are the ones at the front
of the list
because they were the ones that were
least recently accessed. Because when we
access a key, we push we push it back
the iter we push back the key into our
stood list. So the last item in the list
represents kind of like the most
recently accessed and the first is the
least recently accessed. Um and then to
actually store the keys and the values
the thing that I can think of the
easiest thing would be um
probably the an unordered map where the
key is the key and the value would
probably be so I need to store two
pieces of information. And I need the
value, but I also need to know
where this
like item is in our list of least
recently used cache. So the value would
be maybe a pair or a structure of both
the value and then like a list iterator
that points to where where the this key
is in our sto list.
Sounds good. Sounds good.
Yeah. Can we go through different
scenarios?
Sure.
Like a cash cash hit, cash miss,
capacity reached.
Sure. Um, so I guess we'll start with
the easiest one, which is probably the
Well, maybe that's not the easiest one.
Let's just start with like the
empty empty cache. That's probably the
easiest one to start with. So, first
thing I would do is I would check are we
at capacity? Is the unordered map size
the same as our capacity? Right? It's
not in this case. Then the next thing we
check, does this item exist in the cache
currently? And it's not because it's
empty. So all we need to do is push back
the key into our list. And we would then
add the or we would get an iterator to
that last item in the uh list. And we
can do that with I believe end and then
advance it backwards once.
to get the end the end it or we can call
yeah and do that. So we have the
iterator in that way and then we would
just call like insert on the actual
unordered map. We would add in the key
and then the value in the iterator. And
the next case is let's say we're still
not at capacity but there's a cache hit.
So what I would do in that case is I
would get the value from the map. So
sorry yeah and the value would be a
pair. So the actual value of the of the
map of the key and then the iterator
I would erase that iterator from the
list and then I would uh push back that
key to the end of the list so that we've
updated its position in the list
and then if we are at a capacity well we
would do everything that we did before
but the first thing that we do I guess
at the top of the method would be check
if we're full we are full so we get the
iter we get the the key value at the
front of the list we call front and then
we would get that key. We would then
erase that key from the uh unordered map
and then we would pop front off the
list.
Sounds good. Sounds good. That's uh um
that's that's what I have in mind. Cool.
Great.
So that is pretty much all my technical
questions. I want to go over your resume
a little bit here.
Sure.
The rest of this interview was just
going over my resume. This should be the
easiest part of the interview because
you should know it like the back of your
hand. I'm going to put this full uncut
rest of the interview on my Patreon for
patrons to take a look. You can join in
the description box below. If you guys
found this useful, consider becoming a
channel member and also consider joining
getcrack.io io where you can practice
similar problems and get corrected.
